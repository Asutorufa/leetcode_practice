package main

import (
	"fmt"
	"strconv"
)

/**
给定一个数字，我们按照如下规则把它翻译为字符串：
	0 翻译成 “a” ，
	1 翻译成 “b”，
	……，
	11 翻译成 “l”，
	……，
	25 翻译成 “z”。
	一个数字可能有多个翻译。
请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。

示例 1:
输入: 12258
输出: 5
解释: 12258有5种不同的翻译，分别是"bccfi", "bwfi", "bczi", "mcfi"和"mzi"

提示：
    0 <= num < 2^31
*/

/**
这是一道典型的动态规划题目。对于一个数 num[i]，我们有两种选择：
    只翻译自己；
    和前面的数字组合翻译，前提是组合的数在 10−25 之间。

我们可以用 dp(i) 表示前 i 个数字的翻译方法数。根据以上两种选择，我们进行如下分析：
    *如果只翻译自己，比如 12345，如果 5 单独翻译，那么方法数与 1234 是一样的， dp(i)=dp(i−1)。
    如果和前面的数字组合，比如 1235，如果 35 组合翻译，从两方面考虑：
        - 35 看成一个整体，虽然加了 5 但是和没加是一样的，状态 dp(i)=dp(i−1)；
        - 35 组合就意味着不能再组合了，相当于条件 1 中的单独翻译自己，方法数与 12 是一样的。这时 dp(i)=dp(i−2)
        - 以上两种情况相加即可。

故状态转移函数为：

		 +-> dp(i−2)+dp(i−1) 前面两个数在1–25之间
dp(i)  --|
		 +-> dp(i−1)  else

再考虑边界条件：

dp(0)=dp(1)=1

注意：条件 1 星号处不是 dp(i)=dp(i−1)+1。比如 12 如果 2 单独翻译，12 只有一种翻译方法。
*/

func translateNum(num int) int {
	s := strconv.Itoa(num)
	l := len(s)
	res := make([]int, 3)
	res[0] = 0
	res[1] = 1
	res[2] = 1 // 初始化, 写到循环之外, 减少if语句的调用次数

	for index := 1; index < l; index++ { // 循环从1开始, 0 已经写到循环外了
		res[0] = res[1] // 直到前一个字符的所有可组合数
		res[1] = res[2] // 上一个字符的所有可组合数

		if s[index-1:index+1] <= "25" && s[index-1:index+1] >= "10" { // 两位数 10 - 25之间
			res[2] += res[0] // 如果前一个字符+当前字符在10-25之间, 说明可组合, 加上前一个的数量
		}
		// fmt.Println(s[index-1:index+1], res)
	}
	return res[2]
}

func main() {
	fmt.Println(translateNum(12258))
	fmt.Println(translateNum(26))
	fmt.Println(translateNum(542))
}
