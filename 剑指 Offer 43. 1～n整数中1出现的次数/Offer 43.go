package main

import "fmt"

/**
输入一个整数 n ，求1～n这n个整数的十进制表示中1出现的次数。
例如，输入12，1～12这些整数中包含1 的数字有1、10、11和12，1一共出现了5次。

示例 1：
输入：n = 12
输出：5

示例 2：
输入：n = 13
输出：6

限制：
    1 <= n < 2^31
*/

/**
这个比较难理解
将 111 ~ nnn 的个位、十位、百位、...的 111 出现次数相加，即为 111 出现的总次数。 -> 就是把其中一位固定为 1  然后统计这个位固定之后所有的个数
个人理解:
cur=0:
	2 3 0 4
	出现 1 的数字的范围: 0010 - 2219 -> 22 * 10 + 10
												^
												|
											0,1....9 共十个
cur=1:
	2 3 1 4
	出现 1 的数字的范围: 0010 - 2314 -> 23 * 10 + 5
											   ^
											   |
											0,1...4 共5个
cur=2:
	2 3 2 4
	出现1的数字的范围: 0010 -> 2319 -> 23 * 10 + 10 <- 这里的 10 与cur=0时相同

其他人的题解:
case 1: cur=0
     2  3   0  4
     千位和百位可以选00 01 02....22  十位可以取到1( 形如[00|01..|22]1[0-9] 都是<2304 ) 个位可以选0-9  共有 23 * 10 中排列
     当千位和百位取23,如果十位取1 那就是形如 231[0-9] > 2304,所以当千位和百位取23，十位只能能取0，个位取0-4即 2300 2301 2302 2303 2304
     但是2301不应该算进来，这个1是 单独  出现在个位的（而11，121,111这种可以被算多次）
     即 23*10
case 2: cur=1
   2  3  1  4
   千位和百位可以选00 01 02....22  十位可以取到1 个位可以选0-9  共有 23 * 10 中排列
   当千位和百位取23,十位取1，个位可以去0-4 即 2310-2314共5个
   即 23 *10 + 4 +1
case 3: cur>1 即2-9
   2  3  2  4
   千位和百位可以选00 01 02....22  十位可以取到1(形如 [00|01...|22]1[0-9] 都是<2324) 个位可以选0-9  共有 23 * 10 中排列
   当千位和百位取23,十位取1，个位可以去0-9 即 2310-2319共10个 （其中2311，被计算了两次，分别是从个位和十位分析得到的1次）
   即 23 *10 + 10
*/
func countDigitOne(n int) int {
	high := n / 10
	cur := n % 10
	low := 0
	digit := 1
	res := 0
	for high != 0 || cur != 0 {
		if cur == 0 {
			res += high * digit
		} else if cur == 1 {
			res += high*digit + low + 1
		} else {
			res += (high + 1) * digit
		}
		low += cur * digit
		cur = high % 10
		high /= 10
		digit *= 10
	}
	return res
}

func main() {
	fmt.Println(countDigitOne(12))
}
