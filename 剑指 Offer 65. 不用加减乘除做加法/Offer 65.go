package main

import (
	"fmt"
	"math"
)

/**
写一个函数，求两个整数之和，要求在函数体内不得使用 “+”、“-”、“*”、“/” 四则运算符号。

示例:
输入: a = 1, b = 1
输出: 2

提示：
    a, b 均可能是负数或 0
    结果不会溢出 32 位整数
*/

/**
一. 十进制计算
大家都举5+7的例子。那我另想一个例子，计算十进制13+9：

1.计算不进位的和。十位1不变，个位3加9等于2，结果为12；
2.计算进位。十位没进位，个位进位为1，结果为10。

再计算十进制12+10：
1.计算不进位的和。十位1加1等于2，个位2加0等于2，结果为22；
2.计算进位。十位没进位，个位也没进位，结果为0。

因此结果13+9=22。

二. 二进制计算
13二进制为：1101，9二进制为：1001。

十进制是遇到大于等于10就保留余数，然后进位1。
那对应到二进制，就是遇到2就保留余数0，然后进位1。（二进制位之和不可能大于2）

计算二进制1101+1001：
1.计算不进位的和。从左到右，第1位为0，第2位为1，第3位为0，第4位为0，结果为0100；
2.计算进位。从左到右，第1位进位1，第2、3位没有进位，第4位进位1，结果为1001。不对，进位右边要补0，正确结果是10010。

计算二进制0100+10010：
1.计算不进位的和：10110；
2.计算进位：无。

因此结果为10110=22。

三.二进制加法公式

1）分析上面对二进制的计算过程，不难发现：
1.计算不进位的和，相当于对两个数进制异或：1101^1001=0100；
2.计算进位，第1位相当于对两个数求与：1101&1001=1001，然后再对其进行左移1位：1001<<1=10010。
然后再重复以上两个步骤。这里再异或一次就得到结果了，没进位：0100^10010=10110=22。

2）计算a+b，等价于(a^b)+((a&b)<<1)。
由于公式中又出现了+号，因此要再重复2）这个等价的计算过程。
结束条件是：没有进位了。

如果不明白，看一下前一点1）。
*/
// 看上面别人写的题解, 只看三应该就能懂
// 写个 5 + 4的例子
// 5 -> 101, 4 -> 100, ^ -> 异或, & -> 交
// 101 ^ 100  = 001,  101 & 100  << 1 = 1000
// 001 ^ 1000 = 1001, 001 & 1000 << 1 = 00000
// 进位等于0了, 所以结果是 1001
func add(a, b int) int {
	for b != 0 {
		x := a ^ b
		y := (a & b) << 1
		// fmt.Printf("a: %b, b: %b, a&b<<1: %b, a^b: %b\n", a, b, y, x)
		a = x
		b = y
		/**
		精简一下
		c := (a & b) << 1
		a ^= b
		b = c
		*/
	}
	return a
}

func main() {
	fmt.Println(add(5, 4))
	fmt.Println(add(5, 2))
	fmt.Println(add(4, 6))
	fmt.Println(add(7, 9))
}

/**
失败品
*/

// 写了半天 没写成
func add2(a int, b int) int {
	res := 0
	count := 1
	for a > 0 || b > 0 {
		if a&1 != 0 && b&1 != 0 {
			res <<= 1
			res |= 1
		} else if a&1 != 0 || b&1 != 0 {
			res |= 1
		}
		res <<= 1
		count++
		a >>= 1
		b >>= 1
	}
	fmt.Println(res, res>>1, count)
	tmp := 0
	fmt.Printf("%b\n", res)
	for i := 0; i <= count; i++ {
		if res&int(math.Pow(float64(2), float64(i))) != 0 {
			tmp |= int(math.Pow(float64(2), float64(count-i)))
		}
		// tmp <<= 1
		fmt.Printf("%b ", tmp)
		fmt.Println(tmp)
		// res >>= 1
	}
	fmt.Println(tmp)
	return 0
}
