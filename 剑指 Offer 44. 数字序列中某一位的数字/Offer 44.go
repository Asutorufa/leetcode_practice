package main

import (
	"fmt"
	"strconv"
)

/**
数字以0123456789101112131415…的格式序列化到一个字符序列中。
在这个序列中，第5位（从下标0开始计数）是5，第13位是1，第19位是4，等等。
请写一个函数，求任意第n位对应的数字。

示例 1：
输入：n = 3
输出：3

示例 2：
输入：n = 11
输出：0

限制：
    0 <= n < 2^31
*/

// 找规律
// 每次循环减去某几位数的数位总和 循环条件用当前的剩余值与下一个几位数的数位总和进行比较
// 然后用当前位数的起始值加上剩余的值除以位数得到的值就是要找的值
// 然后进行求余对值定位
/**
0 占第0位
1～9 共9x1 = 9个数字 占位9x1 = 9 位
10～99 共9x10 = 90个数字 占位90x2 = 180 位
100～999 共9x100 = 900个数字 占位900x3 = 2700 位
....

规律是不是很好理解啦，算法的逻辑就是：
	我们依次算一下占位数字，并不断地累加得到当前的总占位数，
	并判断和输入n的关系，总占位数小于n的话说明，第n位不在目前的范围內，继续累加；
	否则，说明在范围，然后找到相应数字返回。
	举个例子秒懂：

假设输入n为14，我们想找到第14位：

(1)此时设置当前位置为0的位置 temp=0
(2)占1位的数字有9个: num=9,（1～9,除了0因为temp已设为0了）
(3)占1位 base=1
(4)我们判断一下，当占1位的数字都走完了，目前一共占到了多少位：
	temp + num x base = 0 + 9x1 = 9，
	说明占1位的数字走完后，当前占到了第9位。(更新temp=temp + num x base = 9）
(5)和输入的值比较下，9 < 14,说明我们想找的第14位不在当前占1位的数字中。
(6)那就有可能在占2位的数字中，所以这一轮我们看看占2位的数字（10～99）：
每个数字占位 base = base + 1 = 2
有多少个数字 num = num x 10 = 90
再回到第（4)步，算一下当占2位的数字也都走完了，目前一共占到了多少位
temp + num x base = 9 + 90 x 2 = 189
说明当占2位的数字走完后，当前占到了第189位
再回到第5步，发现 189 > 14,说明我们想找到的数字就在10～99之间
此时，循环终止...因为没必要再往下算占3位的情况了

(7)我们知道第14位就在10～99之间的话就很好办了：
前一轮我们知道占1位的数字走完后，占到了第9位，那我们想找的第14位的值也就是9之后的第5位：
14 - 9 = 5位
占两位的数字中（10～99），第一个起始数字是10，（10 = 10的1次方，也就10的(base-1)次方）
由于10～99这个范围内的数字，都是占base=2位，
所以 5/2 = 2
10 + 2 = 12，第14位就在数字12里
5%2 = 1，说明第14位就是数字12中的第一个位置值，如果把12当成字符串，那就是下标为0的值
“12”.charAt(1-1) = 1
最终我们找到了这个1

验证下0123456789101112...第14位确实是1
*/
func findNthDigit(n int) int {
	start := 1
	digit := 1
	count := 9
	for n > count {
		n -= count
		digit++
		start *= 10
		count = 9 * start * digit
		// fmt.Println("n", n, "start", start, "digit", digit, "count", count)
	}
	num := start + (n-1)/digit
	// fmt.Println("num", num, "(n-1)/digit", (n-1)/digit, "(n-1)%digit", (n-1)%digit)
	return int(strconv.Itoa(num)[(n-1)%digit] - '0')
}

func main() {
	fmt.Println(findNthDigit(3))
	fmt.Println(findNthDigit(11))
	fmt.Println(findNthDigit(1100))
}
