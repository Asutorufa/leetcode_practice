package main

import (
	"fmt"
)

/*
给你一根长度为 n 的绳子，
请把绳子剪成整数长度的 m 段（m、n都是整数，n>1并且m>1），
每段绳子的长度记为 k[0],k[1]...k[m-1] 。
请问 k[0]*k[1]*...*k[m-1] 可能的最大乘积是多少？
例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。

示例 1：
输入: 2
输出: 1
解释: 2 = 1 + 1, 1 × 1 = 1

示例 2:
输入: 10
输出: 36
解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36

提示：

    2 <= n <= 58
*/

/*
	dp

思路示例, 此处长度为10:
当前长度: 4
长度为 1 的最大分段乘积( 1 )乘以长度为 3 的最大分段乘积( 3 )
长度为 2 的最大分段乘积( 2 )乘以长度为 2 的最大分段乘积( 2 )
长度为 4 的最大分段乘积为: 4
当前长度: 5
长度为 1 的最大分段乘积( 1 )乘以长度为 4 的最大分段乘积( 4 )
长度为 2 的最大分段乘积( 2 )乘以长度为 3 的最大分段乘积( 3 )
长度为 5 的最大分段乘积为: 6
当前长度: 6
长度为 1 的最大分段乘积( 1 )乘以长度为 5 的最大分段乘积( 6 )
长度为 2 的最大分段乘积( 2 )乘以长度为 4 的最大分段乘积( 4 )
长度为 3 的最大分段乘积( 3 )乘以长度为 3 的最大分段乘积( 3 )
长度为 6 的最大分段乘积为: 9
当前长度: 7
长度为 1 的最大分段乘积( 1 )乘以长度为 6 的最大分段乘积( 9 )
长度为 2 的最大分段乘积( 2 )乘以长度为 5 的最大分段乘积( 6 )
长度为 3 的最大分段乘积( 3 )乘以长度为 4 的最大分段乘积( 4 )
长度为 7 的最大分段乘积为: 12
当前长度: 8
长度为 1 的最大分段乘积( 1 )乘以长度为 7 的最大分段乘积( 12 )
长度为 2 的最大分段乘积( 2 )乘以长度为 6 的最大分段乘积( 9 )
长度为 3 的最大分段乘积( 3 )乘以长度为 5 的最大分段乘积( 6 )
长度为 4 的最大分段乘积( 4 )乘以长度为 4 的最大分段乘积( 4 )
长度为 8 的最大分段乘积为: 18
当前长度: 9
长度为 1 的最大分段乘积( 1 )乘以长度为 8 的最大分段乘积( 18 )
长度为 2 的最大分段乘积( 2 )乘以长度为 7 的最大分段乘积( 12 )
长度为 3 的最大分段乘积( 3 )乘以长度为 6 的最大分段乘积( 9 )
长度为 4 的最大分段乘积( 4 )乘以长度为 5 的最大分段乘积( 6 )
长度为 9 的最大分段乘积为: 27
当前长度: 10
长度为 1 的最大分段乘积( 1 )乘以长度为 9 的最大分段乘积( 27 )
长度为 2 的最大分段乘积( 2 )乘以长度为 8 的最大分段乘积( 18 )
长度为 3 的最大分段乘积( 3 )乘以长度为 7 的最大分段乘积( 12 )
长度为 4 的最大分段乘积( 4 )乘以长度为 6 的最大分段乘积( 9 )
长度为 5 的最大分段乘积( 6 )乘以长度为 5 的最大分段乘积( 6 )
长度为 10 的最大分段乘积为: 36
36
*/
func cuttingRope(n int) int {
	if n <= 3 { // 稍加推导即可得出
		return n - 1
	}
	dp := make([]int, n+1)
	dp[0] = 0
	dp[1] = 1
	dp[2] = 2
	dp[3] = 3 // 此处与上面不同是因为这里是作为乘数, 且自己比分段大, 所以直接使用自己的值就行了

	for i := 4; i <= n; i++ { // 转化为每个小段长度乘积的问题
		fmt.Println("当前长度:", i)
		max := 0
		for j := 1; j <= i/2; j++ { // 除以2是因为, 类似(2,3)和(3,2)这种相同, 所以应当除以2
			fmt.Println("长度为", j, "的最大分段乘积(", dp[j], ")乘以长度为", i-j, "的最大分段乘积(", dp[i-j], ")")
			tmp := dp[j] * dp[i-j]
			if tmp > max {
				max = tmp
			}
		}
		fmt.Println("长度为", i, "的最大分段乘积为:", max)
		dp[i] = max
	}
	return dp[n]
}

/*
	推论三： 为使乘积最大，只有长度为 2 和 3 的绳子不应再切分，且 3 比 2 更优 （详情见下表） 。
	贪心算法,需数学证明
		-> https://leetcode-cn.com/problems/jian-sheng-zi-lcof/solution/mian-shi-ti-14-i-jian-sheng-zi-tan-xin-si-xiang-by/

*/

func main() {
	fmt.Println(cuttingRope(2))
	fmt.Println(cuttingRope(10))
	fmt.Println(cuttingRope(20))
}
