package main

import (
	"fmt"
)

/*
给你一根长度为 n 的绳子，
请把绳子剪成整数长度的 m 段（m、n都是整数，n>1并且m>1），
每段绳子的长度记为 k[0],k[1]...k[m-1] 。
请问 k[0]*k[1]*...*k[m-1] 可能的最大乘积是多少？
例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。

示例 1：
输入: 2
输出: 1
解释: 2 = 1 + 1, 1 × 1 = 1

示例 2:
输入: 10
输出: 36
解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36

提示：

    2 <= n <= 58
*/

/*
	dp

思路示例, 此处长度为10:
当前长度: 4
长度为 1 的最大分段乘积( 1 )乘以长度为 3 的最大分段乘积( 3 )
长度为 2 的最大分段乘积( 2 )乘以长度为 2 的最大分段乘积( 2 )
长度为 4 的最大分段乘积为: 4
当前长度: 5
长度为 1 的最大分段乘积( 1 )乘以长度为 4 的最大分段乘积( 4 )
长度为 2 的最大分段乘积( 2 )乘以长度为 3 的最大分段乘积( 3 )
长度为 5 的最大分段乘积为: 6
当前长度: 6
长度为 1 的最大分段乘积( 1 )乘以长度为 5 的最大分段乘积( 6 )
长度为 2 的最大分段乘积( 2 )乘以长度为 4 的最大分段乘积( 4 )
长度为 3 的最大分段乘积( 3 )乘以长度为 3 的最大分段乘积( 3 )
长度为 6 的最大分段乘积为: 9
当前长度: 7
长度为 1 的最大分段乘积( 1 )乘以长度为 6 的最大分段乘积( 9 )
长度为 2 的最大分段乘积( 2 )乘以长度为 5 的最大分段乘积( 6 )
长度为 3 的最大分段乘积( 3 )乘以长度为 4 的最大分段乘积( 4 )
长度为 7 的最大分段乘积为: 12
当前长度: 8
长度为 1 的最大分段乘积( 1 )乘以长度为 7 的最大分段乘积( 12 )
长度为 2 的最大分段乘积( 2 )乘以长度为 6 的最大分段乘积( 9 )
长度为 3 的最大分段乘积( 3 )乘以长度为 5 的最大分段乘积( 6 )
长度为 4 的最大分段乘积( 4 )乘以长度为 4 的最大分段乘积( 4 )
长度为 8 的最大分段乘积为: 18
当前长度: 9
长度为 1 的最大分段乘积( 1 )乘以长度为 8 的最大分段乘积( 18 )
长度为 2 的最大分段乘积( 2 )乘以长度为 7 的最大分段乘积( 12 )
长度为 3 的最大分段乘积( 3 )乘以长度为 6 的最大分段乘积( 9 )
长度为 4 的最大分段乘积( 4 )乘以长度为 5 的最大分段乘积( 6 )
长度为 9 的最大分段乘积为: 27
当前长度: 10
长度为 1 的最大分段乘积( 1 )乘以长度为 9 的最大分段乘积( 27 )
长度为 2 的最大分段乘积( 2 )乘以长度为 8 的最大分段乘积( 18 )
长度为 3 的最大分段乘积( 3 )乘以长度为 7 的最大分段乘积( 12 )
长度为 4 的最大分段乘积( 4 )乘以长度为 6 的最大分段乘积( 9 )
长度为 5 的最大分段乘积( 6 )乘以长度为 5 的最大分段乘积( 6 )
长度为 10 的最大分段乘积为: 36
36
*/
func cuttingRope(n int) int {
	if n <= 3 { // 稍加推导即可得出
		return n - 1
	}
	dp := make([]int, n+1)
	dp[0] = 0
	dp[1] = 1
	dp[2] = 2
	dp[3] = 3 // 此处与上面不同是因为这里是作为乘数, 且自己比分段大, 所以直接使用自己的值就行了

	for i := 4; i <= n; i++ { // 转化为每个小段长度乘积的问题
		fmt.Println("当前长度:", i)
		max := 0
		for j := 1; j <= i/2; j++ { // 除以2是因为, 类似(2,3)和(3,2)这种相同, 所以应当除以2
			fmt.Println("长度为", j, "的最大分段乘积(", dp[j], ")乘以长度为", i-j, "的最大分段乘积(", dp[i-j], ")")
			tmp := dp[j] * dp[i-j]
			if tmp > max {
				max = tmp
			}
		}
		fmt.Println("长度为", i, "的最大分段乘积为:", max)
		dp[i] = max
	}
	return dp[n]
}

/**
	推论三： 为使乘积最大，只有长度为 2 和 3 的绳子不应再切分，且 3 比 2 更优 （详情见下表） 。

	贪心算法,需数学证明
		-> https://leetcode-cn.com/problems/jian-sheng-zi-lcof/solution/mian-shi-ti-14-i-jian-sheng-zi-tan-xin-si-xiang-by/

 * 题目分析：
 * 先举几个例子，可以看出规律来。
 * 4 ： 2*2
 * 5 ： 2*3
 * 6 ： 3*3
 * 7 ： 2*2*3 或者4*3
 * 8 ： 2*3*3
 * 9 ： 3*3*3
 * 10：2*2*3*3 或者4*3*3
 * 11：2*3*3*3
 * 12：3*3*3*3
 * 13：2*2*3*3*3 或者4*3*3*3
 *
 * 下面是分析：
 * 首先判断k[0]到k[m]可能有哪些数字，实际上只可能是2或者3。
 * 当然也可能有4，但是4=2*2，我们就简单些不考虑了。
 * 5<2*3,6<3*3,比6更大的数字我们就更不用考虑了，肯定要继续分。
 * 其次看2和3的数量，2的数量肯定小于3个，为什么呢？因为2*2*2<3*3，那么题目就简单了。
 * 直接用n除以3，根据得到的余数判断是一个2还是两个2还是没有2就行了。
 * 由于题目规定m>1，所以2只能是1*1，3只能是2*1，这两个特殊情况直接返回就行了。
 *
 * 乘方运算的复杂度为：O(log n)，用动态规划来做会耗时比较多。
链接：https://www.nowcoder.com/questionTerminal/57d85990ba5b440ab888fc72b0751bf8?f=discussion
来源：牛客网
*/

func main() {
	fmt.Println(cuttingRope(2))
	fmt.Println(cuttingRope(10))
	fmt.Println(cuttingRope(20))
}
